{"version":3,"file":"static/webpack/static/development/pages/index.js.381d80f7ec0af7524d01.hot-update.js","sources":["webpack:///./components/board.jsx"],"sourcesContent":["/* eslint-disable jsx-a11y/mouse-events-have-key-events */\nimport React, { useState, useEffect } from 'react';\nimport * as _ from 'lodash';\nimport Head from 'next/head';\nimport Node from './node';\nimport Dijkstra from '../algorithms/dijkstra';\nimport BFS from '../algorithms/BFS';\nimport DFS from '../algorithms/DFS';\nimport AStar from '../algorithms/AStar';\nimport ButtonBar from './buttonbar';\n\nconst [ROWS, COLS] = [30, 40];\nlet [START_ROW, START_COL] = [15, 2];\nlet [FINISH_ROW, FINISH_COL] = [15, 37];\n\nconst getNode = (row, col, wall = false) => ({\n  row,\n  col,\n  isStart: row === START_ROW && col === START_COL,\n  isFinish: row === FINISH_ROW && col === FINISH_COL,\n  isVisited: false,\n  isWall: wall,\n  distance: Infinity,\n  previousNode: null,\n});\n\nconst getGrid = (walls = null) => {\n  const grid = [];\n  _.each(new Array(ROWS), (_row, rowIndex) => {\n    const currentRow = [];\n    _.each(new Array(COLS), (_col, colIndex) => {\n      // eslint-disable-next-line max-len\n      currentRow.push(getNode(rowIndex, colIndex, walls ? walls[rowIndex][colIndex].isWall : false));\n    });\n    grid.push(currentRow);\n  });\n\n  return grid;\n};\n\nconst toggleWall = (grid, row, col) => {\n  const newGrid = _.clone(grid);\n  const node = newGrid[row][col];\n  if (!(node.isStart || node.isFinish)) {\n    const newNode = _.assign(node, { isWall: !node.isWall });\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\nconst Board = () => {\n  const [nodes, setNodes] = useState(0);\n  const [mousePressed, setMousePressed] = useState(false);\n\n  const handleMouseDown = (row, col) => {\n    setMousePressed(true);\n    setNodes(toggleWall(nodes, row, col));\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mousePressed) return;\n    setNodes(toggleWall(nodes, row, col));\n  };\n\n  const handleMouseUp = () => {\n    setMousePressed(false);\n  };\n\n  const reset = (resetWall = false) => {\n    if (resetWall) {\n      setNodes(getGrid());\n      return;\n    }\n    setNodes(getGrid(nodes));\n    _.each(_.flatten(nodes), (node) => {\n      nodes.isVisited = false;\n      const element = document.getElementById(`node-${node.row}-${node.col}`);\n      if (element) {\n        element.className = _.replace(element.className, /visited/i, '');\n        element.className = _.replace(element.className, /path/i, '');\n      }\n    });\n  };\n\n  const handleEndNodes = (row, col, startDragged = false) => {\n    if (startDragged) {\n      START_ROW = row;\n      START_COL = col;\n    } else {\n      FINISH_ROW = row;\n      FINISH_COL = col;\n    }\n    reset();\n  };\n\n  const getShortestPath = (finishNode) => {\n    const array = [];\n    let currentNode = finishNode;\n    while (currentNode) {\n      array.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return array.reverse();\n  };\n\n  const animateAlgorithm = (visitedNodes, shortestPathNodes) => {\n    _.each(visitedNodes, (node, i) => {\n      if ((node.row === START_ROW && node.col === START_COL)\n        || (node.row === FINISH_ROW && node.col === FINISH_COL)) return;\n      _.delay(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className += ' visited';\n      }, 20 * i);\n    });\n\n    _.each(shortestPathNodes, (node, j) => {\n      if ((node.row === START_ROW && node.col === START_COL)\n        || (node.row === FINISH_ROW && node.col === FINISH_COL)) return;\n      _.delay(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className += ' path';\n      }, visitedNodes.length * 20 + 30 * j);\n    });\n  };\n\n  const visualizeAlgorithm = (type) => {\n    const startNode = nodes[START_ROW][START_COL];\n    const endNode = nodes[FINISH_ROW][FINISH_COL];\n    let visitedNodes = [];\n    switch (type) {\n      case 0: visitedNodes = Dijkstra(nodes, startNode, endNode); break;\n      default:\n      case 1: visitedNodes = BFS(nodes, startNode, endNode); break;\n      case 2: visitedNodes = DFS(nodes, startNode, endNode); break;\n      case 3: visitedNodes = AStar(nodes, startNode, endNode); break;\n    }\n    const shortestPathNodes = getShortestPath(endNode);\n    animateAlgorithm(visitedNodes, shortestPathNodes);\n  };\n\n  const generateMaze = () => {\n    reset();\n    const grid = [];\n    _.each(new Array(ROWS), (_row, rowIndex) => {\n      const currentRow = [];\n      _.each(new Array(COLS), (_col, colIndex) => {\n        let randomness = !!_.round(Math.random() ** 2);\n        if ((rowIndex === FINISH_ROW && colIndex === FINISH_COL)\n          || (rowIndex === START_ROW && colIndex === START_COL)) {\n          randomness = false;\n        }\n        currentRow.push(getNode(rowIndex, colIndex, randomness));\n      });\n      grid.push(currentRow);\n    });\n\n    setNodes(grid);\n  };\n\n  useEffect(() => {\n    setNodes(getGrid());\n    generateMaze();\n  }, []);\n\n  return (\n    <div>\n      <Head>\n        <title>Home</title>\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n\n      <center>\n        <ButtonBar\n          visualizeAlgorithm={visualizeAlgorithm}\n          reset={reset}\n          generateMaze={generateMaze}\n        />\n        <div\n          className=\"board\"\n          onMouseLeave={() => setMousePressed(false)}\n        >\n          {_.map(nodes, (row, rowIdx) => (\n            <div key={rowIdx}>\n              {_.map(row, (node, nodeIdx) => (\n                <Node\n                  key={`${nodeIdx}~~${rowIdx}`}\n                  node={node}\n                  draggable={(node.row === START_ROW && node.col === START_COL)\n                      || (node.row === FINISH_ROW && node.col === FINISH_COL)}\n                  onMouseDown={(_row, col) => handleMouseDown(_row, col)}\n                  onMouseEnter={(_row, col) => handleMouseEnter(_row, col)}\n                  onMouseUp={() => handleMouseUp()}\n                  setEndNodes={handleEndNodes}\n                />\n              ))}\n            </div>\n          ))}\n        </div>\n      </center>\n\n      <style jsx>\n        {`\n        div{\n          line-height: 0;\n        }\n        body{\n          background-color: black;\n        }\n        .board {\n          margin: 0;\n          padding: 12px 0 0;\n          font-size: 13px;\n          color: #333;\n        }\n      `}\n      </style>\n    </div>\n  );\n};\n\nexport default Board;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAAA;AACA;AAUA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AALA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAFA;AAhBA;AAAA;AAAA;AAqDA;AACA;AACA;;;;A","sourceRoot":""}
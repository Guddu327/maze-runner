{"version":3,"file":"static/webpack/static/development/pages/index.js.b81768f72675e9578739.hot-update.js","sources":["webpack:///./algorithms/dijkstra.js"],"sourcesContent":["/* eslint-disable no-continue */\n/* eslint-disable no-param-reassign */\nimport * as _ from 'lodash';\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return _.filter(neighbors, (neighbor) => !neighbor.isVisited);\n}\n\nfunction updateNeighbors(currentNode, grid) {\n  const neighbors = getNeighbors(currentNode, grid);\n  _.each(neighbors, (neighbor) => {\n    neighbor.distance = currentNode.distance + 1;\n    neighbor.previousNode = currentNode;\n  });\n}\n\nfunction sortNodes(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction Dijkstra(grid, startNode, endNode) {\n  const visitedNodes = [];\n  startNode.distance = 0;\n  const unVisitedNodes = _.flatten(_.clone(grid));\n  while (unVisitedNodes.length) {\n    sortNodes(unVisitedNodes);\n    const currentNode = unVisitedNodes.shift();\n\n    if (currentNode.isWall) continue;\n    if (currentNode.distance === Infinity) return visitedNodes;\n    currentNode.isVisited = true;\n\n    visitedNodes.push(currentNode);\n    if (currentNode === endNode) return visitedNodes;\n    updateNeighbors(currentNode, grid);\n  }\n}\n\nexport default Dijkstra;\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AADA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}
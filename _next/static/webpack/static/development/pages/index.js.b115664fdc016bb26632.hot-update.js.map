{"version":3,"file":"static/webpack/static/development/pages/index.js.b115664fdc016bb26632.hot-update.js","sources":["webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/readOnlyError.js","webpack:///./pages/index.jsx"],"sourcesContent":["export default function _readOnlyError(name) {\n  throw new Error(\"\\\"\" + name + \"\\\" is read-only\");\n}","/* eslint-disable jsx-a11y/mouse-events-have-key-events */\nimport React, { useState, useEffect } from 'react';\nimport * as _ from 'lodash';\nimport Head from 'next/head';\nimport Node from '../components/node';\nimport Dijkstra from '../algorithms/dijkstra';\nimport BFS from '../algorithms/BFS';\nimport DFS from '../algorithms/DFS';\n\nconst [ROWS, COLS] = [30, 40];\nconst [START_ROW, START_COL] = [15, 3];\nconst [FINISH_ROW, FINISH_COL] = [28, 35];\n\nconst getNode = (row, col) => ({\n  row,\n  col,\n  isStart: row === START_ROW && col === START_COL,\n  isFinish: row === FINISH_ROW && col === FINISH_COL,\n  isVisited: false,\n  isWall: false,\n  distance: Infinity,\n  previousNode: null,\n});\n\nconst getGrid = () => {\n  const grid = [];\n  _.each(new Array(ROWS), (_row, rowIndex) => {\n    const currentRow = [];\n    _.each(new Array(COLS), (_col, colIndex) => {\n      currentRow.push(getNode(rowIndex, colIndex));\n    });\n    grid.push(currentRow);\n  });\n\n  return grid;\n};\n\nconst toggleWall = (grid, row, col) => {\n  const newGrid = _.clone(grid);\n  const node = newGrid[row][col];\n  if (!(node.isStart || node.isFinish)) {\n    const newNode = _.assign(node, { isWall: !node.isWall });\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\nconst Home = () => {\n  const [nodes, setNodes] = useState(0);\n  const [mousePressed, setMousePressed] = useState(false);\n\n  useEffect(() => {\n    setNodes(getGrid());\n  }, []);\n\n  const handleMouseDown = (row, col) => {\n    setNodes(toggleWall(nodes, row, col));\n    setMousePressed(true);\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mousePressed) return;\n    if (row === START_ROW && col === START_COL) {\n      START_ROW = row;\n      START_COL = col; \n      return;\n    }\n    if (row === FINISH_ROW && col === FINISH_COL) {\n      FINISH_ROW = row;\n      FINISH_COL = col;\n      return;\n    }\n    setNodes(toggleWall(nodes, row, col));\n  };\n\n  const handleMouseUp = () => {\n    setMousePressed(false);\n  };\n\n  const reset = (resetWall = false) => {\n    if (resetWall) {\n      setNodes(getGrid());\n    }\n    _.each(_.flatten(nodes), (node) => {\n      nodes.isVisited = false;\n      nodes.previousNode = null;\n      const element = document.getElementById(`node-${node.row}-${node.col}`);\n      if (element) {\n        element.className = _.replace(element.className, /visited/i, '');\n        element.className = _.replace(element.className, /path/i, '');\n      }\n    });\n  };\n\n  const getShortestPath = (finishNode) => {\n    const array = [];\n    let currentNode = finishNode;\n    while (currentNode) {\n      array.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return array.reverse();\n  };\n\n  const animateAlgorithm = (visitedNodes, shortestPathNodes) => {\n    _.each(visitedNodes, (node, i) => {\n      if (node.row === START_ROW && node.col === START_COL) return;\n      if (node.row === FINISH_ROW && node.col === FINISH_COL) return;\n      _.delay(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className += ' visited';\n      }, 20 * i);\n    });\n\n    _.each(shortestPathNodes, (node, j) => {\n      if (node.row === START_ROW && node.col === START_COL) return;\n      if (node.row === FINISH_ROW && node.col === FINISH_COL) return;\n      _.delay(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className += ' path';\n      }, visitedNodes.length * 20 + 30 * j);\n    });\n  };\n\n  const visualizeAlgorithm = (type) => {\n    const startNode = nodes[START_ROW][START_COL];\n    const endNode = nodes[FINISH_ROW][FINISH_COL];\n    let visitedNodes = [];\n    switch (type) {\n      case 0: visitedNodes = Dijkstra(nodes, startNode, endNode); break;\n      default:\n      case 1: visitedNodes = BFS(nodes, startNode, endNode); break;\n      case 2: visitedNodes = DFS(nodes, startNode, endNode); break;\n    }\n    const shortestPathNodes = getShortestPath(endNode);\n    animateAlgorithm(visitedNodes, shortestPathNodes);\n  };\n\n  return (\n    <div>\n      <Head>\n        <title>Home</title>\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n\n      <center>\n        <button\n          onClick={() => visualizeAlgorithm(0)}\n          type=\"button\"\n        >\n          Visualise Dijkstra\n        </button>\n        <button\n          onClick={() => visualizeAlgorithm(1)}\n          type=\"button\"\n        >\n          Visualise BFS\n        </button>\n        <button\n          onClick={() => visualizeAlgorithm(2)}\n          type=\"button\"\n        >\n          Visualise DFS\n        </button>\n        <button\n          onClick={() => reset(false)}\n          type=\"button\"\n        >\n          Reset\n        </button>\n        <button\n          onClick={() => reset(true)}\n          type=\"button\"\n        >\n          Reset Walls\n        </button>\n        <div\n          className=\"board\"\n          onMouseLeave={() => setMousePressed(false)}\n        >\n          {_.map(nodes, (row, rowIdx) => (\n            <div key={rowIdx}>\n              {_.map(row, (node, nodeIdx) => (\n                <Node\n                  key={nodeIdx}\n                  node={node}\n                  onMouseDown={(_row, col) => handleMouseDown(_row, col)}\n                  onMouseEnter={(_row, col) => handleMouseEnter(_row, col)}\n                  onMouseUp={() => handleMouseUp()}\n                />\n              ))}\n            </div>\n          ))}\n        </div>\n      </center>\n\n      <style jsx>\n        {`\n      div{\n        line-height: 0;\n      }\n      body{\n        background-color: black;\n      }\n      .board {\n        margin: 0;\n        padding: 12px 0 0;\n        font-size: 13px;\n        color: #333;\n      }\n    `}\n      </style>\n    </div>\n  );\n};\n\nexport default Home;\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAAA;AACA;AAUA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAJA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAFA;AAzCA;AAAA;AAAA;AA2EA;AACA;AACA;;;;A","sourceRoot":""}
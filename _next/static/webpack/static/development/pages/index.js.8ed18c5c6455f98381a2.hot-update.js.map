{"version":3,"file":"static/webpack/static/development/pages/index.js.8ed18c5c6455f98381a2.hot-update.js","sources":["webpack:///./pages/index.jsx"],"sourcesContent":["/* eslint-disable jsx-a11y/mouse-events-have-key-events */\nimport React, { useState, useEffect } from 'react';\nimport * as _ from 'lodash';\nimport Head from 'next/head';\nimport { DndProvider } from 'react-dnd';\nimport Backend from 'react-dnd-html5-backend';\nimport Node from '../components/node';\nimport Dijkstra from '../algorithms/dijkstra';\nimport BFS from '../algorithms/BFS';\nimport DFS from '../algorithms/DFS';\nimport AStar from '../algorithms/AStar';\n\nconst [ROWS, COLS] = [15, 20];\nconst [START_ROW, START_COL] = [0, 0];\nconst [FINISH_ROW, FINISH_COL] = [14, 18];\n\nconst getNode = (row, col, wall = false) => ({\n  row,\n  col,\n  isStart: row === START_ROW && col === START_COL,\n  isFinish: row === FINISH_ROW && col === FINISH_COL,\n  isVisited: false,\n  isWall: wall,\n  distance: Infinity,\n  previousNode: null,\n});\n\nconst getGrid = (walls = null) => {\n  const grid = [];\n  _.each(new Array(ROWS), (_row, rowIndex) => {\n    const currentRow = [];\n    _.each(new Array(COLS), (_col, colIndex) => {\n      // eslint-disable-next-line max-len\n      currentRow.push(getNode(rowIndex, colIndex, walls ? walls[rowIndex][colIndex].isWall : false));\n    });\n    grid.push(currentRow);\n  });\n\n  return grid;\n};\n\nconst toggleWall = (grid, row, col) => {\n  const newGrid = _.clone(grid);\n  const node = newGrid[row][col];\n  if (!(node.isStart || node.isFinish)) {\n    const newNode = _.assign(node, { isWall: !node.isWall });\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\nconst Home = () => {\n  const [nodes, setNodes] = useState(0);\n  const [mousePressed, setMousePressed] = useState(false);\n\n  useEffect(() => {\n    setNodes(getGrid());\n  }, []);\n\n  const handleMouseDown = (row, col) => {\n    setMousePressed(true);\n    setNodes(toggleWall(nodes, row, col));\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mousePressed) return;\n    setNodes(toggleWall(nodes, row, col));\n  };\n\n  const handleMouseUp = () => {\n    setMousePressed(false);\n  };\n\n  const reset = (resetWall = false) => {\n    if (resetWall) {\n      setNodes(getGrid());\n      return;\n    }\n    setNodes(getGrid(nodes));\n    _.each(_.flatten(nodes), (node) => {\n      nodes.isVisited = false;\n      const element = document.getElementById(`node-${node.row}-${node.col}`);\n      if (element) {\n        element.className = _.replace(element.className, /visited/i, '');\n        element.className = _.replace(element.className, /path/i, '');\n      }\n    });\n  };\n\n  const getShortestPath = (finishNode) => {\n    const array = [];\n    let currentNode = finishNode;\n    while (currentNode) {\n      array.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return array.reverse();\n  };\n\n  const animateAlgorithm = (visitedNodes, shortestPathNodes) => {\n    _.each(visitedNodes, (node, i) => {\n      if ((node.row === START_ROW && node.col === START_COL)\n        || (node.row === FINISH_ROW && node.col === FINISH_COL)) return;\n      _.delay(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className += ' visited';\n      }, 20 * i);\n    });\n\n    _.each(shortestPathNodes, (node, j) => {\n      if ((node.row === START_ROW && node.col === START_COL)\n        || (node.row === FINISH_ROW && node.col === FINISH_COL)) return;\n      _.delay(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className += ' path';\n      }, visitedNodes.length * 20 + 30 * j);\n    });\n  };\n\n  const visualizeAlgorithm = (type) => {\n    const startNode = nodes[START_ROW][START_COL];\n    const endNode = nodes[FINISH_ROW][FINISH_COL];\n    let visitedNodes = [];\n    switch (type) {\n      case 0: visitedNodes = Dijkstra(nodes, startNode, endNode); break;\n      default:\n      case 1: visitedNodes = BFS(nodes, startNode, endNode); break;\n      case 2: visitedNodes = DFS(nodes, startNode, endNode); break;\n      case 3: visitedNodes = AStar(nodes, startNode, endNode); break;\n    }\n    const shortestPathNodes = getShortestPath(endNode);\n    animateAlgorithm(visitedNodes, shortestPathNodes);\n  };\n\n  let trigger = false;\n  const handleDragStart = (row, col) => {\n    trigger = true;\n  };\n\n  const handleDrop = (row, col) => {\n    if (trigger) {\n    }\n  };\n\n  const generateMaze = () => {\n\n  };\n\n  return (\n    <div>\n      <Head>\n        <title>Home</title>\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n      <DndProvider backend={Backend}>\n        <Board />\n      </DndProvider>\n    </div>\n  );\n};\n\nexport default Home;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAAA;AACA;AAUA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AALA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;A","sourceRoot":""}